<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // console.log(Math.min(...[14, 3, 77]));
      // let apply = Math.max.apply(null, [14, 3, 77]);
      // console.log('====apply', apply);
      // var findmin = function(nums) {
      //   var len = nums.length;
      //   for (var i = 0; i < len - 1; i++) {
      //     if (nums[i] > nums[i + 1]) {
      //       return nums[i + 1];
      //     }
      //   }
      //   return nums[0];
      // };
      // console.log(findmin([3,2,1]));
      // var xor = function(nums) {
      //   let t = 2 ^ 2 ^ 3 ^ 4 ^ 1;
      //   let f = 1 ^ 2 ^ 3 ^ 4;
      //   let t = 0;
      //   for (let i = 0; i < nums.length; i++) {
      //     t ^= nums[i];
      //   }
      // };
      // xor();
      // var find = function(nums) {
      //   var xor = function(prev, cur) {
      //   debugger;
      //     return prev ^ cur;
      //   };
      //   let he = nums.reduce(xor);
      //   return Array.from({ length: nums.length }, (v, i) => i).reduce(
      //     xor,
      //     he
      //   );
      // };
      // let co = find([1,2,2,3,4,]);
      // console.log(co);
      //       /**


      var L1 = createLink([1, 3, 5]);
      var L2 = createLink([2, 4]);
      L1.merge(L2);
      print(L1);
      // 生成链表的构造函数
      function createLink(arr) {
        var LinkNodeList = arr.map(item => new LinkNode(item));
        for (var i = 0; i < arr.length; i++) {
          LinkNodeList[i].next = LinkNodeList[i + 1] || null;
        }
        return LinkNodeList[0];
      }

      function print(linkNode) {
        const arr = [];
        var p = linkNode;
        while (p) {
          arr.push(p.val);
          p = p.next;
        }
        console.log(arr.join(' -> '));
      }

      
      function LinkNode(val) {
        this.val = val;
        this.next = null;
      }
      LinkNode.prototype.merge = function(headL2) {
        var prehead = new LinkNode(-1);
        var prev = prehead;
        var l1 = Object.assign({}, this);
        var l2 = headL2;
        while (l1 !== null && l2 !== null) {
          if (l1.val <= l2.val) {
            prev.next = l1;
            l1 = l1.next;
          } else {
            prev.next = l2;
            l2 = l2.next;
          }
          prev = prev.next;
        }
        prev.next = l1 === null ? l2 : l1;
        this.val = prehead.next.val;
        this.next = prehead.next.next;
      };
    </script>
  </body>
</html>
